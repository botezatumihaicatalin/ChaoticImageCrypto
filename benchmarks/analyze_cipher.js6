import Jimp from 'jimp'
import _ from 'lodash'
import path from 'path'
import { println } from './printing.js6'
import pxutils from './pxutils.js6'

function analyzeCipher(name, options) {

	const images = options.images
	const cipher = options.cipher
	const cipherKey = options.cipherKey

	const readFilePath = (imagePath) => {
		return Jimp.read(imagePath)
	}

	const timeOperation = (method) => {
		let start = _.now(); _.attempt(method)
		return _.now() - start
	}

	const slightlyChangeKey = (cipherKey) => {
		const keyFields = _.keysIn(cipherKey)
		const fieldName = _.sample(keyFields)
		const fieldValue = cipherKey[fieldName]

		const clonedKey = _.clone(cipherKey)
		clonedKey[fieldName] = _.isInteger(fieldValue)
			? (fieldValue + 1) : (fieldValue + 0.00000001)

		return clonedKey
	}

	const testSourceQuality = (bitmap) => {
		const pixels = pxutils.toRgbUint8Array(bitmap.data)
		return {
			chiSquareValue: pxutils.chiSquareTest(pixels),
			globalEntropyValue: pxutils.globalEntropyTest(pixels),
			dimensions: [ bitmap.width, bitmap.height ]
		}
	}

	const testEncryptionQuality = (bitmap) => {
		cipher.initKey(cipherKey)

		const pixels1 = pxutils.toRgbUint8Array(bitmap.data)
		const pixels2 = pxutils.toRgbUint8Array(bitmap.data)
		const randIx = 3 * _.random(0, pixels2.length / 3)
		pixels2[randIx] = (pixels2[randIx] + 128) % 256
		pixels2[randIx+1] = (pixels2[randIx+1] + 128) % 256
		pixels2[randIx+2] = (pixels2[randIx+2] + 128) % 256

		let encrypted1 = undefined
		const encryptDuration = timeOperation(() => {
			encrypted1 = cipher.encrypt(pixels1)
		})
		const encrypted2 = cipher.encrypt(pixels2)
		
		return {
			chiSquareValue: pxutils.chiSquareTest(encrypted1),
			globalEntropyValue: pxutils.globalEntropyTest(encrypted1),
			npcrValue: pxutils.npcrValue(encrypted1, encrypted2),
			uaciValue: pxutils.uaciValue(encrypted1, encrypted2),
			duration: encryptDuration
		}
	}

	const testDecryptionQuality = (bitmap) => {
		const cipherKey1 = cipherKey
		const cipherKey2 = slightlyChangeKey(cipherKey1)
		const cipherKey3 = slightlyChangeKey(cipherKey2)
		const pixels = pxutils.toRgbUint8Array(bitmap.data)

		cipher.initKey(cipherKey1)
		const encrypted = cipher.encrypt(pixels)
		let decrypted1 = null
		const decryptDuration = timeOperation(() => {
			decrypted1 = cipher.decrypt(encrypted)
		}) 

		cipher.initKey(cipherKey2)
		const decrypted2 = cipher.decrypt(encrypted)

		cipher.initKey(cipherKey3)
		const decrypted3 = cipher.decrypt(encrypted)

		return {
			decryptCorrect: _.isEqual(pixels, decrypted1),
			npcrValue: pxutils.npcrValue(decrypted2, decrypted3),
			duration: decryptDuration
		}
	}

	const printSourceQuality = (output) => {
		println(`Testing image quality`, 1, 'green')
		println(`Dimensions are: ${output.dimensions.join(' x ')}`, 2, 'yellow')
		println(`Chi Square Test is: ${output.chiSquareValue}`, 2, 'yellow')
		println(`Global Entropy is: ${output.globalEntropyValue}`, 2, 'yellow')
		return true
	}

	const printEncryptionQuality = (output, padding) => {
		println(`Testing encryption quality`, 1, 'green')
		println(`Encryption took ${output.duration} milliseconds`, 2, 'yellow')
		println(`Chi Square Test is: ${output.chiSquareValue}`, 2, 'yellow')
		println(`Global Entropy is: ${output.globalEntropyValue}`, 2, 'yellow')
		println(`Number of Pixel Change Rate is: ${output.npcrValue}`, 2, 'yellow')
		println(`Unified Average Changing Intensity is: ${output.uaciValue}`, 2, 'yellow')
		return true
	}

	const printDecryptionQuality = (output, padding) => {
		println(`Testing decryption quality`, 1, 'green')
		println(`Decryption took ${output.duration} milliseconds`, 2, 'yellow')
		println(`Decrypted is same as original image? ${output.decryptCorrect}`, 2, 'yellow')
		println(`Number of Pixel Change Rate is: ${output.npcrValue}`, 2, 'yellow')
		return true
	}

	const readAndTestImage = (imagePath) => {
		println(`${name}: ${path.basename(imagePath)}`, 0, 'cyan')
		return readFilePath(imagePath).then((image) => {
			printSourceQuality(testSourceQuality(image.bitmap))
			printEncryptionQuality(testEncryptionQuality(image.bitmap))
			printDecryptionQuality(testDecryptionQuality(image.bitmap))
			println('')
			return true
		}).catch(err => console.error(err))
	}

	println(`Firing up, ${name}`, 0, 'cyanBright')
	let promise = Promise.resolve()
	_.forEach(images, imagePath => {
		promise = promise.then(() => readAndTestImage(imagePath))
	})
	return promise
}

export default analyzeCipher