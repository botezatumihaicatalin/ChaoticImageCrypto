import _ from "lodash"

class PixelsUtils {

  chiSquareTest(pixels, spectrum = 3) {
    const frequencies = _.times(spectrum, () => {
      return _.times(256, () => 0)
    })
    _.forEach(pixels, (value, idx) => {
      frequencies[idx % spectrum][value]++
    })

    const expected   = _.size(pixels) / 256 / spectrum
    const chiSquares = _.times(spectrum, () => 0)

    for (let chan = 0; chan < spectrum; chan++) {
      for (let pixel = 0; pixel < 256; pixel++) {
        const pixelFreq = frequencies[chan][pixel] || 0
        const deltaFreq = pixelFreq - expected
        chiSquares[chan] += deltaFreq * deltaFreq
      }
    }

    for (let chan = 0; chan < spectrum; chan++) {
      chiSquares[chan] /= expected
    }

    return _.mean(chiSquares)
  }

  globalEntropyTest(pixels, spectrum = 3) {
    const frequencies = _.times(spectrum, () => {
      return _.times(256, () => 0)
    })
    _.forEach(pixels, (value, idx) => {
      frequencies[idx % spectrum][value]++
    })

    const imageSize = _.size(pixels) / spectrum
    const entropies = _.times(spectrum, () => 0)

    for (let chan = 0; chan < spectrum; chan++) {
      for (let pixel = 0; pixel < 256; pixel++) {
        const pixelFrequency = frequencies[chan][pixel]
        if (pixelFrequency > 0) {
          const probability = 1.0 * pixelFrequency / imageSize
          entropies[chan] -= probability * Math.log2(probability)
        }
      }
    }

    return _.mean(entropies)
  }

  npcrPercentage(pixels1, pixels2, spectrum = 3) {
    if (!_.isArrayLikeObject(pixels1)
      || !_.isArrayLikeObject(pixels2)) {
      return 0
    }

    const sums      = _.times(spectrum, () => 0)
    const imageSize = _.size(pixels1) / spectrum

    _.forEach(pixels1, (value, idx) => {
      sums[idx % spectrum] += +(value !== pixels2[idx])
    })

    return _.mean(sums) / imageSize * 100
  }

  uaciPercentage(pixels1, pixels2, spectrum = 3) {
    if (!_.isArrayLikeObject(pixels1)
      || !_.isArrayLikeObject(pixels2)) {
      return 0
    }

    const sums      = _.times(spectrum, () => 0)
    const imageSize = _.size(pixels1) / spectrum

    _.forEach(pixels1, (value, idx) => {
      sums[idx % spectrum] += Math.abs(value - pixels2[idx]) / 255
    })

    return _.mean(sums) / imageSize * 100
  }

  msePercentage(pixels1, pixels2, spectrum = 3) {
    if (!_.isArrayLikeObject(pixels1)
      || !_.isArrayLikeObject(pixels2)) {
      return 0
    }

    const sums      = _.times(spectrum, () => 0)
    const imageSize = _.size(pixels1) / spectrum

    _.forEach(pixels1, (value, idx) => {
      sums[idx % spectrum] += Math.pow(value - pixels2[idx], 2)
    })

    return _.mean(sums) / imageSize * 100
  } 

  toRgbUint8Array(pixels) {
    if (!_.isArrayLikeObject(pixels)) {
      return new Uint8Array(0)
    }
    const pixelsSize = _.size(pixels)
    const imageSize  = Math.floor(pixelsSize / 4)

    const outputPixels = new Uint8Array(imageSize * 3)
    for (let idx = 0; idx < imageSize; idx++) {
      for (let chan = 0; chan < 3; chan++) {
        outputPixels[idx * 3 + chan] = pixels[idx * 4 + chan]
      }
    }
    return outputPixels
  }

}

export default new PixelsUtils()